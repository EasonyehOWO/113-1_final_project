
import { generateThumbnail } from './utils/thumbnail_generator.js';

// Global variable to store the auto-generated thumbnail blob
let autoGeneratedThumbBlob = null;

// File input handler
function setupFileInput(inputId, labelId, defaultText, onChangeCallback) {
    document.getElementById(inputId).addEventListener('change', function(e) {
        const label = document.getElementById(labelId);
        if (this.files.length > 0) {
            label.textContent = this.files[0].name;
            label.classList.add('has-file');
            if (onChangeCallback) onChangeCallback(this.files[0]);
        } else {
            label.textContent = defaultText;
            label.classList.remove('has-file');
            if (onChangeCallback) onChangeCallback(null);
        }
    });
}

// 1. Model File Input - Triggers Auto Generation
setupFileInput('modelFile', 'fileLabel', '點擊選擇 3D 模型檔案 (.glb)', async (file) => {
    const previewContainer = document.getElementById('thumbnail-preview-container');
    const previewImg = document.getElementById('thumbnail-preview');

    if (file) {
        // Try to generate thumbnail
        try {
            console.log("Generating thumbnail for", file.name);
            const blob = await generateThumbnail(file);
            autoGeneratedThumbBlob = blob;
            
            // Show preview
            const url = URL.createObjectURL(blob);
            previewImg.src = url;
            previewContainer.style.display = 'block';

        } catch (err) {
            console.error("Auto-thumbnail generation failed:", err);
            previewContainer.style.display = 'none';
            autoGeneratedThumbBlob = null;
        }
    } else {
        previewContainer.style.display = 'none';
        autoGeneratedThumbBlob = null;
    }
});

// 2. Thumbnail File Input - Clears Auto Gen (Optional, logical behavior)
setupFileInput('thumbFile', 'thumbLabel', '點擊選擇縮圖', (file) => {
   // If user selects specific thumb, we might want to hide auto-gen or just keep it as backup.
   // For now, we prefer user file over auto-gen on submit.
});


// Upload form handler
document.getElementById('uploadForm').addEventListener('submit', async function(e) {
    e.preventDefault();
    
    const formData = new FormData(this);
    formData.append('action', 'upload');
    
    // Check if user provided a thumbnail
    const userThumbFile = document.getElementById('thumbFile').files[0];

    // If NO user thumbnail, but we HAVE an auto-generated one, append it
    if (!userThumbFile && autoGeneratedThumbBlob) {
        // Create a filename for it
        const originalName = document.getElementById('modelFile').files[0]?.name || 'model.glb';
        const baseName = originalName.substring(0, originalName.lastIndexOf('.')) || 'model';
        const thumbName = baseName + '_thumb.png';

        formData.append('thumbnail_file', autoGeneratedThumbBlob, thumbName);
        console.log("Attached auto-generated thumbnail:", thumbName);
    }
    
    const uploadBtn = document.getElementById('uploadBtn');
    const uploadLoading = document.getElementById('uploadLoading');
    
    uploadBtn.disabled = true;
    uploadLoading.classList.add('active');
    
    try {
        const response = await fetch('api/upload_action.php', {
            method: 'POST',
            body: formData
        });
        
        const data = await response.json();
        
        if (data.success) {
            showMessage('模型上傳成功！', 'success');
            setTimeout(() => location.reload(), 1500);
        } else {
            showMessage(data.message || '上傳失敗', 'error');
            uploadBtn.disabled = false;
            uploadLoading.classList.remove('active');
        }
    } catch (error) {
        showMessage('網路錯誤，請重試。', 'error');
        uploadBtn.disabled = false;
        uploadLoading.classList.remove('active');
        console.error(error);
    }
});

// Edit model (Exposed to global scope because of onclick handlers in HTML)
window.editModel = function(modelId) {
    const editForm = document.getElementById(`edit-form-${modelId}`);
    editForm.classList.add('active');
};

// Cancel edit
window.cancelEdit = function(modelId) {
    const editForm = document.getElementById(`edit-form-${modelId}`);
    editForm.classList.remove('active');
};

// Save model changes
window.saveModel = async function(modelId) {
    const editForm = document.getElementById(`edit-form-${modelId}`);
    const formData = new FormData(editForm);
    formData.append('action', 'update');
    formData.append('model_id', modelId);
    
    try {
        const response = await fetch('api/upload_action.php', {
            method: 'POST',
            body: formData
        });
        
        const data = await response.json();
        
        if (data.success) {
            showMessage('模型更新成功！', 'success');
            setTimeout(() => location.reload(), 1500);
        } else {
            showMessage(data.message || '更新失敗', 'error');
        }
    } catch (error) {
        showMessage('網路錯誤，請重試。', 'error');
    }
};

// Delete model
window.deleteModel = async function(modelId, title) {
    if (!confirm(`確定要刪除 "${title}" 嗎？此動作無法復原。`)) {
        return;
    }
    
    const formData = new FormData();
    formData.append('action', 'delete');
    formData.append('model_id', modelId);
    
    try {
        const response = await fetch('api/upload_action.php', {
            method: 'POST',
            body: formData
        });
        
        const data = await response.json();
        
        if (data.success) {
            showMessage('模型刪除成功！', 'success');
            setTimeout(() => location.reload(), 1500);
        } else {
            showMessage(data.message || '刪除失敗', 'error');
        }
    } catch (error) {
        showMessage('網路錯誤，請重試。', 'error');
    }
};

// Show message
function showMessage(text, type) {
    const container = document.getElementById('message-container');
    const message = document.createElement('div');
    message.className = `message ${type}`;
    message.textContent = text;
    container.appendChild(message);
    
    setTimeout(() => {
        message.remove();
    }, 5000);
}
